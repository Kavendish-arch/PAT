# 设计模式的分类
总体来说设计模式分为三大类：

## 创建型模式
共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
将对象的创建 与使用分离，从而方便对象的复用。
## 结构型模式
共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
## 行为型模式
共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


# UML 统一建模语言
![img.png](img.png)

## 类图表示方法

## 类与类之间的关系表示方式
1. 继承关系：表示类之间的继承关系，使用 extends 关键字。
2. 实现关系：表示类之间的实现关系，使用 implements 关键字。
3. 关联关系：表示类之间的关联关系，使用 has-a 关键字。
   1. 单向关联
   2. 双向关联
   3. 自关联
4. 聚合关系：表示类之间的聚合关系，使用 has-a 关键字。
5. 组合关系：表示类之间的组合关系，使用 has-a 关键字。
6. 依赖关系：表示类之间的依赖关系，使用 has-a 关键字。

## 创建型模式


## 工厂模式
万物皆对象，如果创建时使用 new 则会对对象产生耦合。 接触到耦合，则需要使用工厂模式。
更换对象需要在工厂类中修改

工厂模式（Factory Pattern）是创建型模式之一，它定义了一个用于创建对象的接口，让子类决定实例化哪一个类。
工厂模式使一个类的实例化延迟到其子类。
### 简单工厂模式
不是设计模式，二十设计规范

结构

抽象产品类: 定义产品的规范
具体产品: 实现的子类
创建工厂类: 创建工厂类，通过工厂类创建对象
封装创建，封装创建过程但修改时需要修改工厂类代码，影响开闭原则

简单工厂模式拓展 静态工厂
### 工厂方法模式
针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。
定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。

结构

工厂方法模式的主要角色:
* 抽象工厂(Abstract Factory):提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
* 具体工厂(concreteractory):主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
* 抽象产品(product):定义了产品的规范，描述了产品的主要特性和功能。
* 具体产品(concreteproduct):实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间--对应。

优缺点：
1. 根据工厂名称得到产品
2. 对拓展开放，对修改关闭

缺点：
1. 类多增加产品需要增加工厂类和产品类

### 抽象工厂模式
将同一种，不同种类的产品抽象为一个对象

## 单例模式
确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
单一类，该类自己创建自己的对象，同时确保只有一个对象被创建
* 单例类
* 访问类

### 分类
* 饿汉式 类加载时创建对象 特点：类加载时创建对象，内存浪费

* 懒汉式 类使用时创建   特点：使用时创建：线程安全问题

实现：
1. 同步锁 
具有性能问题
2. 双重检查锁  
volatile + sysnchronized
3. 静态内部类  
静态内部类单例模式中实例由内部类创建，由于在加载外部类的过程中，是不会加载静态内部类的，只有内部类的属性/方法被调用时才会被加载，
并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。
4. 枚举类型 
枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，
枚举的写法非常简单，而且枚举类型是所用单例实现中唯-一种不会被破坏的单例实现模式。 恶汉模式


### 破坏单例模式
使用单例类创建多个对象，枚举除外
1. 序列化
2. 反射
### 解决方法
1. 添加readResolveObject方法
2. 针对反射的解决方法，修改构造方法 验证

### JDK 实现(Runtime ) 单例模式
```java


public class Runtime {
    // 饿汉式
    private static final Runtime currentRuntime = new Runtime();

    private static Version version;

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class {@code Runtime} are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the {@code Runtime} object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
}
```
### 建造者模式
### 原型模式