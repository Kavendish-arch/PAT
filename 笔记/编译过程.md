//
// Created by newChenyingtao on 2019/10/30.
//

## 预处理 .cpp 头文件展开  .i
* 处理 #define 替换
* 处理 条件预处理指令
* 处理 #include 替换
* 过滤注解
* 保留 #gragma
## 编译 .i compile 语法分析，代码生成 .o
* 词法分析 语法分析 语义分析 代码优化
 * asm -> bin cpp编译过程，
## 链接  .so(linux) .dll(windows) obj   link
## 执行可执行文件  .exe 

1. 加工程的头文件目录：工程---属性---配置属性---c/c++---常规---附加包含目录：加上头文件存放目录。 
2. 添加文件引用的lib静态库路径：工程---属性---配置属性---链接器---常规---附加库目录：加上lib文件存放目录。然后添加工程引用的lib文件名：工程---属性---配置属性---链接器---输入---附加依赖项：加上lib文件名。
 
3. 添加工程引用的dll动态库：把引用的dll放到工程的可执行文件所在的目录下。
     
## C语言编译过程
1. gcc .c -E .i :宏替换 展开文件插入， 删除注释，添加行号
2. gcc .i -S .s :翻译成汇编语言
3. gcc .s -o .o :翻译成二进制文件  可重定位的目标文件
4. gcc .o -o a  :.o -> .o  link .o 格式：ELF PE


## 计算机体系结构————冯诺依曼架构
 *  程序指令存储器和数据存储器合并在一起的存储结构
 *  程序指令和数据宽度相同  intel8086中央处理器 -> X86架构
 *  计算机三基本原则：
 1. 二进制逻辑 
 2. 程序存储执行 
 3. 计算机五大部件（控制器、运算器、存储器、输入、输出设备）
     *  单处理器结构、机器以运算器为核心
     *  采用程序存储思想
     *  指令和数据一样可以参与运算
     *  数据以二级制表示
     *  软件和硬件分离
     *  指令由操作码和数据组成
     *  指令顺序执行
     *  哈佛结构（ARM9) 计算机体系结构

## 程序结构
#include <iostream>     //包含头文件
using namespace std;    //命名空间 cout 定义在std命名空间里
//main()
//int main(){
//    cout << "hello world";
//    return 0;     //程序结束状态返回
//}

### 调试技术：
    GDB 直接调试 gdb --tui
    Emacs+GUD GDB使用入门
    {
        list 显示代码
        
        start 执行
        {
            n（next）可以单步执行程序，
            s（step）命令可以跳入函数中查看函数执行的细节
            bt（backtrace）命令查看程序栈帧，可以在不同栈帧中切换来查看不同环境的变量值。
            使用i（info）查看变量值
            切换至main堆栈，查看main函数中本地变量的值
            p（print）打印某变量的值
            display可以现实每步程序运行之后某变量的值
                不再需要display的结果，可以使用undisplay取消显示
            finish使当前函数运行至return返回
            set var name=value
            break命令在某行设置一个断点
            delete breakpoints num删除断点，使用break（b）查看当前断点分布
        }
    }

### 内存模型：
    C++:强类型语言
    面向过程语言、内存机制
    对象
    类型：什么数据类型
    变量
    值
    2 8 16 进制
    Big Endian  Little Endian
    小      大   大         小

### 内存模型
    逻辑内存    
    栈  stack
        int a; char b;
        function()  $sp
    堆  heap
        动态内存分配 不会自动销毁 会覆盖之前的
        malloc new
        和栈发生对应关系
    静态区
        全局变量
        静态变量
1. 位运算符
    & | ^ ~ << >> 
2. 头文件
    定义
#### 引用和指针
* 引用 定义变量为另一个变量的别名
    int x = 0;
    int *i = x; int *i = (int *)malloc(sizeof(int));
    int &y = x; 已有的变量
* 指针类型，指针变量值为另一个变量的地址
    内存长度固定 8字节
    int *p;
    double *p; 
    p = 0xffff7777; 地址值

### 内存机制：
1. 虚拟内存和内存分页
    内存数据货架 0x00000001 
    地址的范围和地址总线位数相关

    真实内存 --> 虚拟内存 
    真实地址 --> 虚拟地址
    0x00000011 --> 0x00110011
    0x00110011 --> 0x00110011 
优势: 借助虚拟内存，程序无法访问真实地址，减少地址操作出错的问题
真实内存 和 虚拟内存的 映射 产生了 内存分页

* 一个虚拟内存需要多大？ $getconf PAGE_SIZE
    偏移量 4kb = x 12次方
    例如 4096(4kb)(0x000 ---- 0xfff)

        虚拟内存     偏移量     对应关系              真实内存     偏移量
        0x0 0 0 1 a  0x0 1 1   0x0001a -- 0x00006   0x0 0 0 0 6 0x0 1 1  
        范围(0x0001a 0x000 - 0xfff)                 (0x00006 0x000 - 0xfff)
        0x0 0 0 2 b  0x0 1 1   0x0001a -- 0x00007    0x0 0 0 0 7 0x0 1 1
    多级分页表,偏移量(多级)
        虚拟内存2   --->    虚拟内存1 --->      真实内存
        0x00 0x01a 0x011

32位系统内存
4G
    系统内核
3G
    栈 往下
    
    堆 往上
  bss: 未初始化的 全局变量，静态局部变量 
  data：初始化 全局变量，静态局部变量 
  text 代码段 
0x08048000
0G: