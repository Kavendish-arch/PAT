# 同时发起100个http请求，总共会建立多少个TCP连接


## 长连接
长连接：HTTP/1.1 默认是长连接，即连接复用，浏览器默认开启长连接。
1. 非持久连接：HTTP/1.0 中 的首部字段Connection 默认值为 close，即每次请求都会重新建立和断开 TCP 连接。
2. 持久连接：HTTP/1.1 中 的首部字段 Connection 默认值为 keep-alive ，连接可以复用，只要发送端、接收端都没有提出断开连接，则保持tcp连接状态。
http1.1中，所有的连接默认为持久连接，但在http1.0中并未标准化，即使有部分的服务器通过非标准化的手段实现了持久连接，但是服务器端不一定支持持久连接。

3. 如果是 HTTP 2.0 版本协议，支持多用复用，一个 TCP 连接是可以并发多个 HTTP 请求的，同样也是支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送。
   
持久连接的优点：
减少了tcp连接的重复建立和断开所造成的额外开销，减轻了服务器端的负担，其中减少开销的这部分时间实际上也使http请求和响应更早的结束，提高了web页面的显示速度。

二、TCP 连接中多个 HTTP 请求可以并行发送吗？
在http1.1中，单个 TCP 连接在同一时刻只能处理一个请求，即两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。上一个请求得到响应之后，才能发送下一个请求。

管线化（pipelining）
管线化技术的出现，实现了同时发送多个http请求，不必等待上一请求返回响应，但是浏览器默认关闭管线化，原因如下：

一些代理服务器不能正确的处理 HTTP Pipelining。

Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了多个请求。如果按照标准的话，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应，造成了阻塞。

多路复用(Multiplexing)
因为http1.1中的管线化实际上无法使用，因此在http2.0中出现了Multiplexing 多路传输特性。

在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream），帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

三、一个TCP连接可以发送多少个HTTP请求问题？
1、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

关于这个 TCP 连接后是否断开的问题，请参考：nginx中http1.1 KeepAlive 失效
我们知道 Header 中 Connection 属性决定了连接是否持久，HTTP/1.0 中 Connection 默认是 close 的，即每次请求都会重新建立和断开 TCP 连接，而在 HTTP/1.1 中 Connection 默认是 keep-alive 的，即连接可以复用，不用每次都重新建立和断开 TCP 连接。如果想主动断开连接，只需要将 Connection 属性设置为 close 即可，即 Connection: close。一般情况下复用的 TCP 连接在等待设置的超时时间之后还没有被任何连接使用的话，TCP 连接就会主动断开。

2、一个 TCP 连接可以对应几个 HTTP 请求？

了解了第一个问题之后，可以得知如果维持连接的话，一个 TCP 连接是可以发送多个 HTTP 请求的。

3、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，即两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。
虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。
一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。

至于标准为什么这么设定，我们可以推测以下原因：

由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。例如你向服务器发送了两个请求 GET/query?type=1 和 GET/query?type=2，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。
虽然 Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：

1）、一些代理服务器不能正确的处理 HTTP Pipelining
2）、Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了多个请求。如果按照标准的话，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应，造成了阻塞。
结论： 在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

那么在 HTTP/1.1 中，浏览器是如何提高页面加载效率的呢？主要有以下两点：

1）、连接复用，即维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
2）、和服务器建立多个 TCP 连接。
4、为什么有的时候刷新页面不需要重新建立 SSL 连接？

第一个问题已经给出了答案，连接如果是维持的话，是可以复用 TCP 连接的，刷新页面也不需要重新建立 SSL 连接。

5、浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

如果使用的是 HTTP/1.1 ，即没有多路传输，当浏览器需要加载有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定不能接受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，即使你的电脑同意 NAT 也不定同意的。

因此答案是：有，Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。

6、浏览器需要加载有几十张图片的网页时，那么这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。
如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。
————————————————




1.现代浏览器在与服务器建立了一个TCP连接后，是否会在一个HTTP请求完成之后断开？什么情况下会断开？
在HTTP/1.0中，一个服务器在发送完一个HTTP响应后，会断开TCP连接。但是这样每次请求都会重新建立和断开TCP连接，代价过大。所以虽然标准中没有设定，某些服务器对Connection: keep-alive的Header进行了支持。

意思是说，完成这个HTTP请求之后，不要断开HTTP请求使用TCP连接。这样的好处是连接可以被重新使用，之后发送HTTP请求的时候不需要重新建立TCP连接，以及如果维持连接，那么SSL的开销也可以避免。

（SSL：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。）

持久连接: 既然维持TCP连接好处这么多，HTTP/1.1就把Connection头写进标准，并且默认开启持久化连接(除非请求中声明Connection: close)，那么浏览器和服务器之间是会维持一段时间的TCP连接，不会一个请求结束就断掉。

所以第一个问题的答案是: 默认情况下建立TCP连接不会断开，只有在请求报头中声明Connection: close才会请求完成之后关闭连接。

2.一个TCP连接可以对应几个HTTP请求？
由第一题也知道，如果维持连接，一个TCP连接可以发送多个HTTP请求的，但最多多少个呢？还有待思考

3.一个TCP连接中，HTTP请求可以一起发送吗？
HTTP/1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求，意思是说: 两个请求的声明周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠。

虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。

先来看一下 Pipelining 是什么，RFC 2616 中规定了：一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。

至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。

比如你向服务器发送了两个请求 GET /query?q=A 和 GET /query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的（因为TCP都是绑定到一个网络端口的）。

Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：

1.有些代理服务器不能正确的处理 HTTP Pipelining。
2.正确的流水线实现是复杂的。
3.Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。
所以现代浏览器默认是不开启 HTTP Pipelining 的。
但是，HTTP2 提供了 Multiplexing(多路复用) 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。

所以这个问题也有了答案：
在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP请求可以在同一个 TCP 连接中并行进行。

那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

1.维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
2.和服务器建立多个 TCP 连接。

1. 为什么有的时候刷新页面不需要重新建立 SSL 连接？
在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。

5.浏览器对同一 Host 建立 TCP 连接到数量有没有限制？
假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？

肯定不能只开一个TCP连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP连接吧，你的电脑同意 NAT 也不一定会同意。
所以答案是：有。Chrome最多允许对同一个Host建立六个TCP连接。不同的浏览器有一些区别。

那么回到最开始的问题，HTML如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

如果图片都是HTTPS连接并且在同一个域名下，那么浏览器在SSL握手之后会和服务器商量能不能用HTTP2，如果能的话就使用Multiplexing功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个TCP连接去获取，但是可以确定的是 Multiplexing很可能会被用到。

如果发现用不了HTTP2呢？或者用不了HTTPS（现实中的HTTP2都是在HTTPS上实现的，所以也就是只能使用HTTP/1.1）。

那浏览器就会在一个HOST上建立多个TCP连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。

所以标题的答案是：
若是在http/2的情况下，会进行多路复用，只会建立一个；
但是在http/1.1的话，那就看浏览器的最大连接数，拿chrome来说，最多建立6个tcp连接，然后需要一个一个发送，其他未发送的只能排队；所以说chrome是六个，其他浏览器看自身情况
