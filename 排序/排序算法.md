

# 插入排序
# 希尔排序
# 选择排序
* 选择排序，每一趟选择最小的数，按顺序放在最后
## 算法分析
* 时间复杂度
1. 最好情况：正序不移动，O(n^2)
2. 最差情况：数组初始逆序：O(n^2) 移动 3(n-1)
3. 平均： O(n^2)
* 空间复杂度：
  交换空间只需要 O(1)
  
## 算法特点
1. 不稳定排序
2. 可以用链式存储
3. 移动记录次数较少, 当一记录占用空间多，此方法比直接插入快
## 题目

# 堆排序
基本原理：
堆排序（英语：Heap Sort）是一种基于比较的排序算法，可以被视为“使用高效的数据结构实现的选择排序”。与选择排序类似，堆排序将输入数据分为已排序区域和未排序区域，并通过从未排序区域中提取最大元素并将其插入已排序区域来逐步缩小未排序区域。不同于选择排序，堆排序不会浪费时间对未排序区域进行线性扫描，而是通过维持一个堆数据结构来高效地找到每一步中的最大元素。
尽管在大多数计算机上比实现良好的快速排序稍慢，但堆排序具有实现非常简单和更有利的最坏情况时间复杂度 O(nlog⁡n)的优点。大多数实际应用的快速排序变体在检测到快速排序性能下降时，会包括堆排序作为备选方案。堆排序是一种原地算法，但它不是稳定排序算法。

## 堆的概念
1.堆是一种完全二叉树，分为大顶堆和小顶堆。
大顶堆：每个节点的值都大于或等于其子节点的值。
小顶堆：每个节点的值都小于或等于其子节点的值。
## 排序过程
1.首先，将待排序的数组构建成一个堆。
从最后一个非叶子节点开始，逐步调整以满足堆的性质。对于一个长度为n的数组，最后一个非叶子节点的索引为(n/2)-1。
通过不断地比较节点与其子节点的值，进行交换操作，使整个数组满足堆的性质。

2.构建好堆之后，数组的第一个元素就是堆中的最大（或最小）元素。
将第一个元素与最后一个元素交换，此时最大（或最小）元素就被放置在数组的最后位置。
然后，对剩余的n-1个元素重新调整为堆。
3. 重复这个过程，每次将当前堆的最大（或最小）元素与未排序部分的最后一个元素交换，然后调整堆，直到整个数组有序。


## 算法分析
* 时间复杂度
1. 最好情况：O(Nlog2N)
2. 最差情况：数组初始逆序：O(n^2)
3. 平均： O(Nlog2N)
* 空间复杂度：
1. 最好情况: O(log2N)
2. 最坏情况: O(N)
  
## 算法特点
1. 排序不稳定
2. 只适合数组
3. 适合数据量大，创建堆用时多

# 冒泡排序
* 交换排序: 利用两两比较，进行交换
冒泡排序：利用两两比较相邻，使得关键小的上浮
## 算法分析
* 时间复杂度
1. 最好情况：数组初始为正序：一趟比较 O(n-1) 不移动
2. 最差情况：数组初始逆序：O(n^2)
3. 平均： O(n^2)
* 空间复杂度：O(1)
  
## 算法特点
1. 稳定排序
2. 可以用链式存储
3. 移动记录次数较多 算法无序效果差
## 题目

LC 283 移动0

# 快速排序
由冒泡排序改进而来。冒泡排序只对两个相邻的数比较，一次比较消除一个逆序，快排一次比较消除多个逆序。

## 算法分析
* 时间复杂度
1. 最好情况：O(Nlog2N)
2. 最差情况：数组初始逆序：O(n^2)
3. 平均： O(Nlog2N)
* 空间复杂度：
1. 最好情况: O(log2N)
2. 最坏情况: O(N)
  
## 算法特点
1. 排序不稳定
2. 排序过程需要定位上界 下界适合数组
3. 适合初始无序，n较大的情况
## 题目

LC 283 移动0

# 归并排序

# 计数排序
# 桶排序
# 基数排序