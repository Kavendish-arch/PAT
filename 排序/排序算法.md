# 排序算法
[//]: # (## 3.7 排序算法)
### 概述
排序算法大体可分为两种：

一种是比较排序，时间复杂度O(nlogn) 到 O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。
另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。

#### 比较排序算法

| 算法 |    最好    |    最坏    |    平均    |  空间   | 稳定 | 思想 |                           注意事项                           |
| :--: | :--------: | :--------: | :--------: | :-----: | :--: | :--: | :----------------------------------------------------------: |
| 冒泡 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  O(1)   |  Y   | 比较 |                     最好情况需要额外判断                     |
| 选择 |  O($n^2$)  |  O($n^2$)  |  O($n^2$)  |  O(1)   |  N   | 比较 |                     交换次数一般少于冒泡                     |
|  堆  | O($nlogn$) | O($nlogn$) | O($nlogn$) |  O(1)   |  N   | 选择 |         堆排序的辅助性较强，理解前先理解堆的数据结构         |
| 插入 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  O(1)   |  Y   | 比较 | 插入排序对于近乎有序的数据处理速度比较快，复杂度有所下降，可以提前结束 |
| 希尔 |  O(nlogn)  |  O($n^2$)  | O($nlogn$) |  O(1)   |  N   | 插入 |  gap序列的构造有多种方式，不同方式处理的数据复杂度可能不同   |
| 归并 | O($nlogn$) | O($nlogn$) | O($nlogn$) |  O(n)   |  Y   | 分治 |                   需要额外的O(n)的存储空间                   |
| 快速 | O($nlogn$) |  O($n^2$)  | O($nlogn$) | O(logn) |  N   | 分治 | 快排可能存在最坏情况，需要把枢轴值选取得尽量随机化来缓解最坏情况下的时间复杂度 |


#### 非比较排序算法

| 非比较排序算法 | 时间复杂度 | 空间复杂度 | 稳定性 |
| -------------- | ---------- | ---------- | ------ |
| 计数排序       | O(n+k)     | O(n+k)     | 稳定   |
| 桶排序         | O(n+k)     | O(n+k)     | 稳定   |
| 基数排序       | O(d*(n+k)) | O(n+k)     | 稳定   |

其中
* n 是数组长度
* k 是桶长度
* d 是基数位数



#### 稳定 vs 不稳定

[//]: # (![stability_playing_cards.svg]&#40;./imgs/stability_playing_cards.svg.png&#41;)

#### Java 中的排序

Arrays.sort

JDK 7~13 中的排序实现

| 排序目标                      | 条件                                       | 采用算法            |
| ----------------------------- | ------------------------------------------ | ------------------- |
| int[] long[] float[] double[] | size < 47                                  | 混合插入排序 (pair) |
|                               | size < 286                                 | 双基准点快排        |
|                               | 有序度低                                   | 双基准点快排        |
|                               | 有序度高                                   | 归并排序            |
| byte[]                        | size <= 29                                 | 插入排序            |
|                               | size > 29                                  | 计数排序            |
| char[] short[]                | size < 47                                  | 插入排序            |
|                               | size < 286                                 | 双基准点快排        |
|                               | 有序度低                                   | 双基准点快排        |
|                               | 有序度高                                   | 归并排序            |
|                               | size > 3200                                | 计数排序            |
| Object[]                      | -Djava.util.Arrays.useLegacyMergeSort=true | 传统归并排序        |
|                               |                                            | TimSort             |

JDK 14~20 中的排序实现

| 排序目标                      | 条件                                         | 采用算法           |
| ----------------------------- | -------------------------------------------- | ------------------ |
| int[] long[] float[] double[] | size < 44 并位于最左侧                       | 插入排序           |
|                               | size < 65 并不是最左侧                       | 混合插入排序 (pin) |
|                               | 有序度低                                     | 双基准点快排       |
|                               | 递归次数超过 384                             | 堆排序             |
|                               | 对于整个数组或非最左侧 size > 4096，有序度高 | 归并排序           |
| byte[]                        | size <= 64                                   | 插入排序           |
|                               | size > 64                                    | 计数排序           |
| char[] short[]                | size < 44                                    | 插入排序           |
|                               | 再大                                         | 双基准点快排       |
|                               | 递归次数超过 384                             | 计数排序           |
|                               | size > 1750                                  | 计数排序           |
| Object[]                      | -Djava.util.Arrays.useLegacyMergeSort=true   | 传统归并排序       |
|                               |                                              | TimSort            |

* 其中 TimSort 是用归并+二分插入排序的混合排序算法
* 值得注意的是从 JDK 8 开始支持 Arrays.parallelSort 并行排序
* 根据最新的提交记录来看 JDK 21 可能会引入基数排序等优化



#### 外部排序

# 插入排序
* 每一趟从待排序的数据中选出最小的元素，放在已排序的数据中
稳定
数组越有序，越快

# 希尔排序
改进版插入排序，将待排序的数组分割成为若干个子序列，分别进行直接插入排序，待整个序列中的记录排序后，再对全体记录进行一次直接插入排序。


# 选择排序
* 选择排序，每一趟选择最小的数，按顺序放在最后
## 算法分析
* 时间复杂度
1. 最好情况：正序不移动，O(n^2)
2. 最差情况：数组初始逆序：O(n^2) 移动 3(n-1)
3. 平均： O(n^2)
* 空间复杂度：
  交换空间只需要 O(1)
  
## 算法特点
1. 不稳定排序
2. 可以用链式存储
3. 移动记录次数较少, 当一记录占用空间多，此方法比直接插入快
## 题目

# 堆排序
基本原理：
堆排序（英语：Heap Sort）是一种基于比较的排序算法，可以被视为“使用高效的数据结构实现的选择排序”。

与选择排序类似，堆排序将输入数据分为已排序区域和未排序区域，并通过从未排序区域中提取最大元素并将其插入已排序区域来逐步缩小未排序区域。不同于选择排序，堆排序不会浪费时间对未排序区域进行线性扫描，而是通过维持一个堆数据结构来高效地找到每一步中的最大元素。
尽管在大多数计算机上比实现良好的快速排序稍慢，但堆排序具有实现非常简单和更有利的最坏情况时间复杂度 O(nlog⁡n)的优点。大多数实际应用的快速排序变体在检测到快速排序性能下降时，会包括堆排序作为备选方案。堆排序是一种原地算法，但它不是稳定排序算法。

## 堆的概念
1.堆是一种完全二叉树，分为大顶堆和小顶堆。
大顶堆：每个节点的值都大于或等于其子节点的值。
小顶堆：每个节点的值都小于或等于其子节点的值。
## 排序过程
1.首先，将待排序的数组构建成一个堆。
从最后一个非叶子节点开始，逐步调整以满足堆的性质。对于一个长度为n的数组，最后一个非叶子节点的索引为(n/2)-1。
通过不断地比较节点与其子节点的值，进行交换操作，使整个数组满足堆的性质。

2.构建好堆之后，数组的第一个元素就是堆中的最大（或最小）元素。
将第一个元素与最后一个元素交换，此时最大（或最小）元素就被放置在数组的最后位置。
然后，对剩余的n-1个元素重新调整为堆。
3. 重复这个过程，每次将当前堆的最大（或最小）元素与未排序部分的最后一个元素交换，然后调整堆，直到整个数组有序。


## 算法分析
* 时间复杂度
1. 最好情况：O(Nlog2N)
2. 最差情况：数组初始逆序：O(n^2)
3. 平均： O(Nlog2N)
* 空间复杂度：
1. 最好情况: O(log2N)
2. 最坏情况: O(N)
  
## 算法特点
1. 排序不稳定
2. 只适合数组
3. 适合数据量大，创建堆用时多

# 冒泡排序
* 交换排序: 利用两两比较，进行交换
冒泡排序：利用两两比较相邻，使得关键小的上浮


**要点**

1. 每轮冒泡不断比较, 如果是逆序的，则交换，否则不交换
2. 找到合适的右边界，调整有边界，减少不必要比较：减少轮数 记录最后一次交换索引的位置

算法分析

* 时间复杂度
1. 最好情况：数组初始为正序：一趟比较 O(n-1) 不移动
2. 最差情况：数组初始逆序：O(n^2)
3. 平均： O(n^2)
* 空间复杂度：O(1)
  
## 算法特点
1. **稳定排序**
2. 可以用链式存储
3. 移动记录次数较多 算法无序效果差
## 题目

LC 283 移动0

# 快速排序
由冒泡排序改进而来。冒泡排序只对两个相邻的数比较，一次比较消除一个逆序，快排一次比较消除多个逆序。
1. 单边循环 lomuto分区 要点：
  * 选择最右边的元素为基准点
  * j 找比基准点小的元素，找到后，i 找比基准点大的，两者交换
  * 最后基准点与 i 交换， i 为基准点最终位置

2. 双边循环 hoare分区 要点：
  * 选择最左侧的为基准点
  * j 找比 基准点小的，i 找比基准点大的， 一旦找到，二者交换
    * j 从右向左，i 从左向右
  * 最后基准点与 i 交换， i 为基准点最终位置

## 算法分析
* 时间复杂度
1. 最好情况：O(Nlog2N)
2. 最差情况：数组初始逆序：O(n^2)
3. 平均： O(Nlog2N)
* 空间复杂度：
1. 最好情况: O(log2N)
2. 最坏情况: O(N)
  
## 算法特点
1. 排序不稳定
2. 排序过程需要定位上界 下界适合数组
3. 适合初始无序，n较大的情况
## 题目

LC 283 移动0

# 归并排序
要点：
1. 最好最坏平均都是 O(nlogn)
2. 空间复杂度 O(n)
3. 分治思想
* 分 没错切一半，排序
* 治 当数据仅剩下一个默认为有序
* 合 两个有效结果合并

# 组合排序算法
1. 归并排序+插入排序

# 桶排序
## 计数排序
要点
1. 找到最大值，创建一个大小为 最大值+1 的 count 数组
2. count 数组的索引对应原始数组的元素，用来统计该元素的出现次数
3. 遍历 count 数组，根据 count 数组的索引(即原始数组的元素)以及出现次数，生成排序后内容 
4. count 数组的索引是:已排序好的

前提:待排序元素>=0 且最大值不能太大
改进：对于复数增加偏移量 abs(min)
## 桶排序
要点：
1. 桶排序是计数排序的改进，它将整数按位数切割成不同的数字，然后按每个位数分别比较。

### 计数排序和桶排序区别

## 基数排序
1. 低位优先
    桶排序的一种特殊情况，当数据是整数时，可以按照低位优先的方式，将数据收集到桶中，然后依次收集到数组中。


练习：
1. 1122. 数组的相对排序
2. 1636 . 按照频率将数组升序排序

